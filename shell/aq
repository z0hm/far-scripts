#!/bin/bash
# Bash script - interface for [Album Player Console](http://albumplayer.ru/linux/ap64.tar.gz "apc")
# ![aq script](http://i.piccy.info/i9/ce0b78c019db240a75a21f00089bfd7a/1600717787/7655/1397248/2020_09_21_221429.png)
# ![aq script](http://i.piccy.info/i9/b978141af12e993afff139bb461039db/1600717816/39618/1397248/946922020_09_21_223718.png)
# Commands:
# **e** - exit, **x** - exit with save path, just **Enter** - repeat last command
# **l** - list files in folder, **a**/**z** - show **previous**/**next** 100 files
# **c<num>** - convert file to **/tmp/out.wav**, **v<num>** - view content of file
# **<num>** - play file <num>, **p**/**n** - play **previous**/**next** file, after **Enter** **Enter** ...
# **<num>.<num>:<num>** or **<num>:<num>** - play file number <num> from min:sec
# **<num>.<num>** or **.<num>** - play file <num> from track number <num>, if cue sheet loaded
# **s** - stop playback, **r** - return on jump history, after **Enter** **Enter** ...
# **ro<num>**/**rw<num>** - remount **FAT** partition as **read only**/**writable**, available in **/media** folder only
# **cp<num>** - copy file to **/media/flash**, **mv<num>** - move file, **rm<num>** - remove file
# Url: http://albumplayer.ru/linux/english.html

# init
home=/media
aqpage=/tmp/aqpage
aqjump=/tmp/aqjump
appath=/usr/ap/path.txt
pglen=100
exts=(WAV FLAC APE WV OGG TAK ALAC AIFF DFF DSF MP3 MP4 AAC OPUS WMA)
# hmstr="ap /"
# hmlen=${#hmstr}
arr0=()  # array files in folder
arr1=()  # array files type
arr2=()  # array music files attribute
jump=()  # jumps stack
num=0
oldnum=0
lastnum=0
page=0
start=0
finish=0
last=0
id=-1
path=""
folder=""
from=""
msg=""
strS="                                                                                 "

# colors
rk="\e[1;31;40m"
yr="\e[1;33;41m"
yg="\e[1;33;42m"
yb="\e[1;33;44m"
yk="\e[1;33;40m"
wr="\e[1;37;41m"
wg="\e[1;37;42m"
wb="\e[1;37;44m"
eb="\e[1;30;44m"
wk="\e[1;37;40m"
gb="\e[1;32;44m"
gk="\e[1;32;40m"
cb="\e[1;36;44m"
ck="\e[1;36;40m"
te="\e[0m"


bye(){
  echo -e "$yb bye! $te\n"
  exit 0
}

# view files
vname=""; vpath=""
fview(){
  tmp1=$eb; tmp2=$te
  read -r -N 3 line <<< "$(cat "$vpath")"
  if [[ ! ( ${line:0:1} == $'\xEF' && ${line:1:1} == $'\xBB' && ${line:2:1} == $'\xBF' ) ]] && [[ $(cat "$vpath") =~ [^\000-\127] ]]
  then tmp=$vpath; vpath=/tmp/$vname; if [ "$tmp" != "$home/temp/$vname" ]; then iconv -c -f CP1251 -t UTF-8 "$tmp" > "$vpath"; fi
  fi
  if [[ $vname =~ ^.+\.([^\.]+)$ ]]
  then
    if   [ ${BASH_REMATCH[1]} == "CUE" -o ${BASH_REMATCH[1]} == "cue" ]; then tmp1=$yb; tmp2=$yk
    elif [ ${BASH_REMATCH[1]} == "LOG" -o ${BASH_REMATCH[1]} == "log" ]; then tmp1=$cb; tmp2=$ck
    elif [ ${BASH_REMATCH[1]} == "TXT" -o ${BASH_REMATCH[1]} == "txt" ]; then tmp1=$cb; tmp2=$ck
    fi
  fi
  echo -e "$yb view:$tmp1 $num $tmp2 $vname$te"
  exec 6<&0  # save STDIN to descriptor #6
  local n=0
  while read -r line
  do n=$(($n+1))
    if [ $n -gt $pglen ]
    then
      n=0
      exec 7<&0 <&6  # save current descriptor to descriptor #7 and restore STDIN from descriptor #6
      read -p "$(echo -e "vw>$wk enter$gk a$wk for abort or just press$gk Enter$wk for next $pglen lines: $te")"
      if [ "$REPLY" == "a" ]; then break; fi
      exec <&7  # restore input from vpath
    fi
    echo -ne "$wb"; echo -nE "$line"; echo -e "$te"
  done <<< "$(cat "$vpath")"
  exec 6<&- 7<&-  # close descriptors #6 & #7
}

# read cue
rdcue(){
  track=0; unset cuenm; cuenm=(); unset cuepf; cuepf=(); unset cuefl; cuefl=(); unset cuetm; cuetm=(); unset cueln; cueln=(); cuewd=0
  while read line
  do
    if [[ $line =~ TRACK[' ']([0-9][0-9])[' ']AUDIO ]]; then track=$(($track+1)); fi
    if [[ $line =~ TITLE[' ']\"[' ']*(.+)[' ']*\" ]]
    then cuenm[$track]=${BASH_REMATCH[1]}
      if [ $track -gt 0 ]; then cueln[$track]=${#cuenm[$track]}; if [ ${cueln[$track]} -gt $cuewd ]; then cuewd=${cueln[$track]}; fi; fi
    fi
    if [[ $line =~ PERFORMER[' ']\"[' ']*(.+)[' ']*\" ]]; then cuepf[$track]=${BASH_REMATCH[1]}; fi
    if [[ $line =~ FILE[' ']\"[' ']*(.+)[' ']*\" ]]; then cuefl[$track]=${BASH_REMATCH[1]}; fi
    if [[ $line =~ INDEX[' ']01[' ']([0-9]+:[0-9]+) ]]; then cuetm[$track]=${BASH_REMATCH[1]}; fi
  done <<< "$(cat "$vpath")"
  read -r -N 3 line <<< "$(cat "$vpath")"
  if [[ ! ( ${line:0:1} == $'\xEF' && ${line:1:1} == $'\xBB' && ${line:2:1} == $'\xBF' ) ]] && [[ $(cat "$vpath") =~ [^\000-\127] ]]
  then tmp=$vpath; vpath=/tmp/$vname; if [ "$tmp" != "$home/temp/$vname" ]; then iconv -c -f CP1251 -t UTF-8 "$tmp" > "$vpath"; fi
    track=0; unset cuenm; cuenm=(); unset cuepf; cuepf=(); unset cuefl; cuefl=()
    while read line
    do
      if [[ $line =~ TRACK[' ']([0-9][0-9])[' ']AUDIO ]]; then track=$(($track+1)); fi
      if [[ $line =~ TITLE[' ']\"[' ']*(.+)[' ']*\" ]]; then cuenm[$track]=${BASH_REMATCH[1]}; fi
      if [[ $line =~ PERFORMER[' ']\"[' ']*(.+)[' ']*\" ]]; then cuepf[$track]=${BASH_REMATCH[1]}; fi
      if [[ $line =~ FILE[' ']\"[' ']*(.+)[' ']*\" ]]; then cuefl[$track]=${BASH_REMATCH[1]}; fi
    done <<< "$(cat "$vpath")"
  fi
}

shcue(){
  echo -e "$wb==================================$yb cue sheet $wb==================================="
  echo -e "$yb Album: $cb${cuenm[0]}"
  echo -e "$yb Perf:  $cb${cuepf[0]}"
  echo -e "$yb File:  $cb${cuefl[0]}"
  for ((i=1;i<=${#cuetm[*]};i++))
  do
    if [ $i -lt 10 ]; then tmp2=" "; else tmp2=""; fi
    echo -e "$gb $i $wb$tmp2 ${cuenm[$i]}${strS:0:$(($cuewd-${cueln[$i]}))} $yb ${cuetm[$i]}"
    if [ "${cuepf[$i]}" != "" ] && [ "${cuepf[$i]}" != "${cuepf[$(($i-1))]}" ] && [ "${cuepf[$i]}" != "${cuenm[$i]}" ]; then echo -e "$yb Perf:  $cb${cuepf[$i]}"; fi
    if [ "${cuefl[$i]}" != "" ]; then echo -e "$yb File:  $cb${cuefl[$i]}"; fi
  done
  echo -e "$wb================================================================================$te"
}

# show page
shpage(){
  start=$(($page*$pglen))
  finish=$(($start+$pglen-1))
  if [ $finish -gt $last ]; then finish=$last; fi
  unset mus; mus=(); unset cue; cue=()
  for ((i=start;i<=finish;i++))
  do arr2[$i]=false
    if [ "$path" == "$home" ] && [ -w "$path/${arr0[$i]}" ]
    then echo -e "$wb $i $rk ${arr0[$i]}$te"
    else
      if [ "$from" == "${arr0[$i]}" ]
      then echo -e "$wb $i $wr ${arr0[$i]} $te"
      else
        if ${arr1[$i]}
        then echo -e "$wb $i $wk ${arr0[$i]}$te"
        else
          ext=""; res=false
          for v in ${exts[@]}
          do
            ext=${arr0[$i]:(-$((${#v}+1)))}
            if [ "$ext" == ".$v" -o "$ext" == ".${v,,}" ]; then res=true; break; fi
          done
          if $res
          then arr2[$i]=true; mus+=($i); echo -e "$gb $i $gk ${arr0[$i]}$te"
          else
            if [ "$ext" == ".CUE" -o "$ext" == ".cue" ]; then cue+=($i); echo -e "$yb $i $yk ${arr0[$i]}$te"
            elif [ "$ext" == ".TXT" -o "$ext" == ".txt" ] || [ "$ext" == ".LOG" -o "$ext" == ".log" ]
            then echo -e "$cb $i $ck ${arr0[$i]}$te"; else echo -e "$eb $i $te ${arr0[$i]}"
            fi
          fi
        fi
      fi
    fi
  done
  if [ ${#cue[*]} -gt 0 ] && [ ${#mus[*]} -eq 1 ]; then echo; vname=${arr0[${cue[0]}]}; vpath=$path/$vname; rdcue; shcue; fi
}

# seek folder and its id
seekid(){
  folder=${path##*/}
  local n=0
  while read line
  do n=$(($n+1)); if [ "$line" == "$folder" ]; then id=$n; break; fi
  done <<< "$(ls "${path%/*}")"
}

# msg for command line
prompt(){
  if [ $page -gt 0 ]; then key_a="$wk,$gk a"; else key_a=""; fi
  if [ $finish -lt $last ]; then key_z="$wk,$gk z"; else key_z=""; fi
  if [ ${#jump[*]} -gt 1 ]; then key_r="$wk,$gk r"; else key_r=""; fi
  if [ "$path" == "$home" ]; then key_rw="$wk,$gk ro<num>$wk,$gk rw<num>"; else key_rw=""; fi
  msg=$(echo -ne "\naq>$wk enter$gk 0$wk..$gk$last$wk or$gk l$key_r$wk,$gk s$wk,$gk x$key_a$key_z$key_rw$wk, or$te nothing$wk: $te")
}

# kill ap
killap(){
  while read line
  do if [ "${line:0:4}" == "ap /" ]; then killall -q ap; sleep 1s; break; fi
  done <<< "$(ps -o args)"
}

# save state
aqsave(){
  echo "$page" > "$aqpage"
  echo -n "$path" > "$appath"
  if [ -f $aqjump ]; then rm $aqjump; fi
  for ((i=0;i<=$((${#jump[*]}-1));i++)); do echo "${jump[i]}" >> "$aqjump"; done
}

cdir(){
  cd "$path"
  if [ "$oldnum" != "r" ]; then jump+=("$path"); fi
  break #goto show
}

prevpl(){
  if [ "$oldnum" == "p" ] || [ "$oldnum" == "n" ]; then num=$lastnum; else num=$oldnum; fi
  oldnum="p"
  if [ -n "$num" ] && [ "$num" -eq "$num" ] 2>/dev/null
  then if [ $num -gt 1 ] && ${arr2[$(($num-1))]}; then num=$(($num-1)); lastnum=$num; break; fi
  fi
}

nextpl(){
  if [ "$oldnum" == "n" ] || [ "$oldnum" == "p" ]; then num=$lastnum; else num=$oldnum; fi
  oldnum="n"
  if [ -n "$num" ] && [ "$num" -eq "$num" ] 2>/dev/null
  then if [ $num -lt $last ] && ${arr2[$(($num+1))]}; then num=$(($num+1)); lastnum=$num; break; fi
  fi
}

aqhelp(){
  echo -e "$gk e$wk  exit,$gk x$wk  exit with save path,$te nothing$wk  repeat last command$te"
  echo -e "$gk l$wk  list files,$gk a$wk  show previous $pglen files,$gk z$wk  show next $pglen files$te"
  echo -e "$gk c<num>$wk  convert file to /tmp/out.wav,$gk v<num>$wk  view content of file$te"
  echo -e "$gk <num>$wk  play file <num>,$gk p$wk  play previous file,$gk n$wk  play next file$te"
  echo -e "$gk <num>.<num>:<num>$wk or$gk <num>:<num>$wk  play file number <num> from min:sec$te"
  echo -e "$gk <num>.<num>$wk or$gk .<num>$wk  play track number <num> if cue sheet loaded$te"
  echo -e "$gk s$wk  stop track,$gk r$wk  return, remount $gk ro<num>$wk, remount $gk rw<num>$te"
  echo -e "$gk cp<num>$wk  copy file to $home/flash,$gk mv<num>$wk  move file,$gk rm<num>$wk  remove file$te"
}

# Main()
echo -e "\n$yr -=[ AP console quiet ]=- $te"
echo -e "\n$gk h$wk  help,$gk e$wk  exit,$gk x$wk  exit with save path$te\n"
# load settings
if [ -s "$aqpage" ]; then page=$(<$aqpage); fi
if [ -s "$aqjump" ]; then while read line; do jump+=("$line"); done <<< "$(cat "$aqjump")"; else jump[0]="$home"; fi
path=${jump[@]:(-1)}

while true #:show
do
  unset arr0; arr0=(); unset arr1; arr1=(); unset arr2; arr2=()
  if [ "$path" == "$home" ]
  then arr0[0]=$(echo -e "$yb[ EXIT ]$te")
  else
    if [ $id -lt 0 ]; then seekid; fi
    echo -e "$yg $id $wg $folder $te\n"
    arr0[0]=$(echo -e "$wk..$te"); arr1[0]=true
  fi
  while read line
  do
    if [ "${line:(-1)}" == "/" ]; then arr0+=("${line:0:(-1)}"); arr1+=(true)
    elif [ "$line" != "" ]; then arr0+=("$line"); arr1+=(false)
    fi
  done <<< "$(ls -pL "$path")"
  last=$((${#arr0[*]}-1))
  shpage
  while true #:cline
  do
    if [ "$oldnum" != "r" ] && [ "$oldnum" != "n" ] && [ "$oldnum" != "p" ]; then oldnum=$num; fi
    prompt
    while read -p "$msg" num
    do
      tight=true
      if [[ $num =~ ^([1-9][0-9]*)\.([1-9][0-9]*)$ ]]
      then
        if [ ${BASH_REMATCH[1]} -le ${#arr0[*]} ] && ${arr2[${BASH_REMATCH[1]}]} && [ ${BASH_REMATCH[2]} -le ${#cuetm[*]} ]
        then num=${BASH_REMATCH[1]}; timeshift=${cuetm[${BASH_REMATCH[2]}]}; oldnum=$num; break
        fi
      elif [[ $num =~ ^\.([1-9][0-9]*)$ ]] && [ ${#cue[*]} -gt 0 ] && [ ${#mus[*]} -eq 1 ] && [ ${mus[0]} -lt ${#arr0[*]} ] && ${arr2[${mus[0]}]}
      then
        if [ ${BASH_REMATCH[1]} -le ${#cuetm[*]} ]
        then num=${mus[0]}; timeshift=${cuetm[${BASH_REMATCH[1]}]}; oldnum=$num; break
        fi
      elif [[ $num =~ ^([0-9]+)\.([0-9]+[\.:][0-9]+)$ ]]
      then num=${BASH_REMATCH[1]}; timeshift=${BASH_REMATCH[2]}; if [ $num -lt ${#arr0[*]} ]; then oldnum=$num; break; fi
      elif [[ $num =~ ^[0-9]+:[0-9]+$ ]] && [ ${#mus[*]} -eq 1 ]; then timeshift=${BASH_REMATCH[0]}; num=${mus[0]}; oldnum=$num; break
      fi
      timeshift=0
      if   [ "$num" == "" ] && [ ${#arr0[*]} -lt 2 ] && [ "$oldnum" != "r" ]; then num=0; oldnum=$num; break
      elif [ "$num" == "" ] && [ ${#arr1[*]} -eq 2 ] && ${arr1[1]} && [ "$oldnum" != "r" ]
      then if [ ${#jump[$((${#jump[*]}-2))]} -lt ${#jump[$((${#jump[*]}-1))]} ]; then num=1; else num=0; fi; oldnum=$num; break
      elif [ "$num" == "x" ]; then echo; aqsave; bye
      elif [ "$num" == "e" ]; then echo; bye
      elif [ "$num" == "h" ]; then echo; aqhelp; tight=false
      elif [ "$path" == "$home" ] && [[ $num =~ ^(r[ow])([1-9][0-9]*)$ ]]
      then if [ ${BASH_REMATCH[2]} -lt $((${#arr0[*]}-1)) ]; then echo; vname=${arr0[${BASH_REMATCH[2]}]}; vpath=$path/$vname; mount -o remount,${BASH_REMATCH[1]} $vpath; shpage; tight=false; fi
      elif [[ $num =~ ^c([1-9][0-9]*)$ ]]
      then
        if [ ${BASH_REMATCH[1]} -lt ${#arr0[*]} ]
        then vname=${arr0[${BASH_REMATCH[1]}]}
          if ${arr2[${BASH_REMATCH[1]}]}
          then echo
            killap
            ffmpeg -y -i "$path/$vname" -acodec pcm_s32le "/tmp/out.wav"
            echo -e "$yb play:$gb $num $gk $vname$te"
            ap "/tmp/out.wav"
            tight=false
          fi
        fi
      elif [[ $num =~  ^v([1-9][0-9]*)$ ]]; then if [ ${BASH_REMATCH[1]} -lt ${#arr0[*]} ]; then vname=${arr0[${BASH_REMATCH[1]}]}; echo; vpath=$path/$vname; fview; tight=false; fi
      elif [[ $num =~ ^cp([1-9][0-9]*)$ ]]; then if [ ${BASH_REMATCH[1]} -lt ${#arr0[*]} ]; then vname=${arr0[${BASH_REMATCH[1]}]}; echo; cp "$path/$vname" "$home/flash"; tight=false; fi
      elif [[ $num =~ ^mv([1-9][0-9]*)$ ]]; then if [ ${BASH_REMATCH[1]} -lt ${#arr0[*]} ]; then vname=${arr0[${BASH_REMATCH[1]}]}; echo; mv "$path/$vname" "$home/flash"; tight=false; fi
      elif [[ $num =~ ^rm([1-9][0-9]*)$ ]]; then if [ ${BASH_REMATCH[1]} -lt ${#arr0[*]} ]; then vname=${arr0[${BASH_REMATCH[1]}]}; echo; rm "$path/$vname"; tight=false; fi
      fi
      if [ "$num" == "" ]; then num=$oldnum; fi
      if [ "$num" == "r" ]
      then
        oldnum=$num
        if [ ${#jump[*]} -gt 1 ]
        then
          unset jump[$((${#jump[*]}-1))]
          newpath=${jump[@]:(-1)}
          if [ ${#newpath} -lt ${#path} ]
          then num=0
          else curpath=$path; path=$newpath; seekid; num=$id; path=$curpath
          fi
          break
        else oldnum="xxx"; num="xxx"; echo -ne "\e[1A\r"  # wrong command for re-query
        fi
      elif [ "$num" == "s" ]; then echo -e "\n$yb stop $te"; killap
      elif [ "$num" == "l" ]; then echo; shpage
      elif [ "$num" == "z" -a $finish -lt $last ]; then echo; page=$(($page+1)); oldnum=$num; shpage
      elif [ "$num" == "a" -a $page -gt 0 ]; then echo; page=$(($page-1)); oldnum=$num; shpage
      elif [ "$num" == "p" ]; then echo; prevpl
      elif [ "$num" == "n" ]; then echo; nextpl
      #elif [ -n "$num" ] && [ "$num" -eq "$num" ] 2>/dev/null
      elif [[ $num =~ ^[0-9]+$ ]]
      then if [ $num -lt ${#arr0[*]} ]; then oldnum=$num; break; fi
      else if $tight; then echo -ne "\e[1A\r"; fi
      fi
      prompt
    done
    echo
    if [ $num -eq 0 ]
    then  #cdup
      from=${path##*/}
      if [ "$path" == "$home" ]
      then bye
      else
        seekid
        page=$(($id/$pglen))
        id=-1
        path="${path%/*}"
        cdir
      fi
    else  #cddn
      id=$num
      folder=${arr0[$num]}
      from=""
      path="$path/${arr0[$num]}"
      if ${arr1[$num]}; then page=0; cdir
      elif [ -f "$path" ]
      then
        ext=""; res=false
        for v in ${exts[@]}
        do
          ext=${arr0[$num]:(-$((${#v}+1)))}
          if [ "$ext" == ".$v" -o "$ext" == ".${v,,}" ]; then res=true; break; fi
        done
        if $res
        then
          killap
          echo -e "$yb play:$gb $num $gk ${arr0[$num]}$te"
          ap "$path" $timeshift
        else
          vname=${arr0[$num]}; vpath=$path
          if [ "$ext" == ".CUE" -o "$ext" == ".cue" ]; then rdcue; shcue; aqsave; fi
          if [ "$ext" == ".TXT" -o "$ext" == ".txt" ] || [ "$ext" == ".LOG" -o "$ext" == ".log" ]; then fview; fi
        fi
        path=${jump[@]:(-1)}
        seekid
        # continue #goto cline
      fi
    fi
  done #goto cline
done #goto show
